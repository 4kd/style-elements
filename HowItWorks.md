
# Getting Started

First, check out the examples

 * a simple example: [code]() - [demo]()
 * a realworld example that uses animations, media queries, and palettes: [code]() - [demo]()
 * documentation (Unpublished for the moment, will be published soon)


## Style Crafting

The `Style` module has the tools you need to craft a style.  Essentially you do this by creating a `Style.Model` record.  

The `Style.Model` is a pretty large record with a handful of required properties. By having required properties, we make an element be styled the same no matter where it occurs in your document.  In other words we remove the context-aware part of CSS to make our styles portable and easier to think about.

Back to the point of the `Style.Model` being large; you don't need to write an entire `Style.Model` by hand for every style in your library.  Generally you'll create one foundational style and then all the other styles will be based on that foundation.  This allows us to have very explicit inheritance which makes styling much easier to think about.

There's still one big question though; How do we associate a style with an html node?  Usually you'd do this with a `class` or `id`, but this library does things a bit differently.


## Attaching Styles to Elements

Instead of relying on `classes` and `ids`, the `style-elements` library focuses on creating collections of styled elements that you can pull from and use to build your view.  While this may seem bizarre, the benefit is that your views look cleaner and more meaningful, and we still maintain our ability to express style variations like we would with classes (such as if you're used to using `classList`).


The `Style.Elements` module has the tools to attach a style to an html node.  We call an html node with an attached style a `Style.Element`, and it works very similarly to the nodes from the `Html` library that you're used to.

You can use `Html.Attributes` and `Html.Events` on them as you would.  The only requirement is that the child nodes are `Style.Element`s as well.

If this seems confusing, check out the examples.


### Building a Stylesheet

Once your view is composed of `Style.Element`s, you can call `Style.Elements.build` at the top-most element.  This gathers all the styling information you've specified in the elements of your view and builds a stylesheet.  This stylesheet is then embedded into the html.


> We have to use style sheets because inline styles can't express desireable things like media queries and animations.  However this library doesn't require you to write css classes, so how does a stylesheet associate styles with an html node?
>
> Internally, a classname for a style is generated by taking a murmur3 hash of the style properties.  This classname is also used to eliminate redundant styles when the stylesheet is created.


Options for generating external css stylesheets are currently being considered.


## A Starterkit

The `Style.Basic` module contains useful styles to get you started.

The `Style.Elements.Basic` module contains useful elements to start with.

__Text elements__
> 
> `text`, `i`, `b`, `u`, `s`, `sup`, `sub`, `break`, `sup`, `sub`
> 
> You should use these! Here's why.
>
> A `Style.Element` has mandatory properties.  This generally makes styling much easier to think about because once an element is styled, it doesn't matter where it shows up in your document, it will have that style.
>
> However this doesn't make sense for text markup.  Lets say we use 2 fonts and 3 font sizes.  If we kept with out mandatory properties idea here and wanted to be able to italicize anything, we'd have to create 6 additional styles to represent italicizing a font at a specific size.
>
> These text elements solve this by just not having the mandatory properties, so you can mark up your text anywhere.


__Basic Layout Elements__

These are elements that can be used to set layout without having to craft a custom style as you normally would.








